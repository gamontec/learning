// computeforces.js// // particle and gravity simulation.//// rld, 6.07//inlets = 3;outlets = 2;var PARTICLE_COUNT = 1000; // initial number of particle verticesvar ATTRACTOR_COUNT = 3; // initial number of points of gravity// create two [jit.expr] objects for the bang_expr() function// first expression: sum all the planes in the input matrixvar myexpr = new JitterObject("jit.expr");myexpr.expr = "in[0].p[0]+in[0].p[1]+in[0].p[2]"; // second expression: evaluate a+((b-c)*d/e)var myexpr2 = new JitterObject("jit.expr");myexpr2.expr = "in[0]+((in[1]-in[2])*in[3]/in[4])"; // create the Jitter matrices we need to store our data// matrix of x,y,z particle verticesvar particlemat = new JitterMatrix(3, "float32", PARTICLE_COUNT); particlemat.adapt = 1;// matrix of x,y,z particle velocitiesvar velomat = new JitterMatrix(3, "float32", PARTICLE_COUNT);velomat.planemap = [0, 1, 2];velomat.adapt = 1;// matrix of x,y,z points of attraction (gravity centers)var attmat = new JitterMatrix(3, "float32", ATTRACTOR_COUNT); attmat.adapt = 1;// matrix for aggregate distancesvar distmat = new JitterMatrix(3, "float32", PARTICLE_COUNT); distmat.adapt = 1;// temporary matrix for the bang_expr() functionvar tempmat = new JitterMatrix(3, "float32", PARTICLE_COUNT); tempmat.adapt = 1;// temporary summing matrix for the bang_expr() functionvar summat = new JitterMatrix(1, "float32", PARTICLE_COUNT); summat.adapt = 1;// a scalar matrix to store the current gravity pointvar scalarmat = new JitterMatrix(3, "float32", PARTICLE_COUNT); scalarmat.usesrcdim = 1;scalarmat.planemap = [0, 1, 2];// a scalar matrix to store acceleration (expr_expr() function)var amat = new JitterMatrix(1, "float32", PARTICLE_COUNT); amat.usesrcdim = 1;amat.planemap = 3;// matrix to store decay points from the velomatvar dmat = new JitterMatrix(1, "float32", PARTICLE_COUNT); dmat.planemap = 3;function jit_matrix(v) // execute when a matrix comes in{	if(inlet==0) {		particlemat.frommatrix(v);		amat.dim = particlemat.dim;		scalarmat.dim = particlemat.dim;		summat.dim = particlemat.dim;		PARTICLE_COUNT = particlemat.dim;		bang(); // draw on left inlet	}	if(inlet==1) {		velomat.frommatrix(v);		dmat.dim = velomat.dim;		dmat.frommatrix(v);	}	if(inlet==2) {		attmat.frommatrix(v);		ATTRACTOR_COUNT = attmat.dim;		//post(ATTRACTOR_COUNT, "\n");	}}function bang() // perform one iteration of our particle system{	bang_expr();	// output our new matrix of particle vertices 	// with the current drawing primitive	outlet(1, "jit_matrix", velomat.name);	outlet(0, "jit_matrix", particlemat.name);}function bang_expr() // create our particle matrix using [jit.expr]{	for(var i = 0; i < ATTRACTOR_COUNT; i++) 	// do one iteration per gravity point	{		// create a scalar matrix out of the current attractor's position:		scalarmat.srcdimstart = i;		scalarmat.srcdimend = i;		scalarmat.frommatrix(attmat);		// create a scalar matrix out of our attractor's acceleration value:		amat.srcdimstart = i;		amat.srcdimend = i;		amat.frommatrix(attmat);		// subtract our particle positions from the current attractor 		// and store in a temporary matrix (x,y,z):		tempmat.op("-", scalarmat, particlemat); 		// square to create a cartesian distance matrix (x*x, y*y, z*z):		distmat.op("*", tempmat, tempmat); 		// sum the planes of the distance matrix (x*x+y*y+z*z) : 		// "in[0].p[0]+in[0].p[1]+in[0].p[2]" : 		myexpr.matrixcalc(distmat, summat);		summat.op("max", 0.01); // keep the distance matrix above 0		// derive amount of motion for this frame : 		// "in[0]+((in[1]-in[2])*in[3]/in[4])" :		myexpr2.matrixcalc([velomat,scalarmat,particlemat,amat,summat],	velomat); 	} 	// offset our current positions by the amount of motion:	particlemat.op("+", velomat); 	// reduce our velocities by the decay factor for the next frame:	velomat.op("*", dmat); } 